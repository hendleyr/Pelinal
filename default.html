<!DOCTYPE html>
<html lang="en">
	<head>
		<title>test</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #61443e;
				font-family:Monospace;
				font-size:13px;
				text-align:center;

				background-color: #bfd1e5;
				margin: 0px;
				overflow: hidden;
			}

			#info {
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
			}

			a {
				color: #a06851;
			}

		</style>
	</head>
	<body>

		<div id="container"><br /><br /><br /><br /><br />Generating world...</div>
		<div id="info"><a href="http://threejs.org" target="_blank">three.js</a> - test<br />(left click: forward, right click: backward)</div>

		<script src="scripts/Three.js"></script>
		<script src="scripts/shaders/ShaderToon.js"></script>
		<script src="scripts/FirstPersonControls.js"></script>

		<script src="scripts/ImprovedNoise.js"></script>
		<script src="scripts/Detector.js"></script>
		<script src="scripts/libs/stats.min.js"></script>
        <script src="scripts/shaders/three_lambertoon_anim.js"></script>

        <script id="vertexShader" type="x-shader/x-fragment">
            struct appdata
            {
                vec4 position;
                vec4 COL0;
            };

            struct vfconn
            {
                vec4 HPOS;
                vec4 COL0;
                vec4 COL1;
                vec4 TEX0;
                vec4 TEX1;
                vec4 TEX2;
                vec4 TEX3;
                vec4 TEX4;
                vec4 TEX5;
                vec4 TEX6;
            };

            precision highp float;
            attribute vec3 position;
            attribute vec3 normal;
            uniform mat3 normalMatrix;
            uniform mat4 modelViewMatrix;
            uniform mat4 projectionMatrix;
            varying vec3 fNormal;
            varying vec3 fPosition;
            //
            uniform appdata IN;
            uniform sampler2D HMap0;
            uniform sampler2D tex1;
            uniform sampler2D tex2;
            uniform sampler2D HMap1;
            uniform vec4 Gabarites;
            uniform vec4 VOfs     ;
            uniform vec4 CPos     ;
            uniform vec4 MapRTrasf;
            uniform vec4 Expld[2];

            // Vertex shader for DM calculation
            vec4 tex2D_bilinear4(sampler2D tex, vec4 t, vec2 Scales)
            {
              float size  = Scales.x;
              float scale = Scales.y;

              //if (f.x < 0) f.x = 1+f.x;
              //if (f.y < 0) f.y = 1+f.y;
              //t-=f;
              vec4 t00 = texture2DProj(tex, t);
              vec4 t10 = texture2DProj(tex, t + vec4(scale,0,0,0));

              vec2 f = fract(t.xy*size);

              vec4 tA  = mix(t00, t10, f.x);

              vec4 t01 = texture2DProj(tex, t + vec4(0,scale,0,0));
              vec4 t11 = texture2DProj(tex, t + vec4(scale,scale,0,0) );

              vec4 tB  = mix(t01, t11, f.x);
              return mix(tA, tB, f.y);
            }

            float tex2D_bilinear4x(sampler2D tex, vec4 t, vec2 Scales)
            {
              float size  = Scales.x;
              float scale = Scales.y;


              vec4 tAB0 = texture2DProj(tex, t);

              vec2 f = fract(t.xy*size);

              vec2 tAB  = mix(tAB0.xz, tAB0.yw, f.x);
              return mix(tAB.x, tAB.y, f.y);
            }

            float tex2D_trilinear(sampler2D tex, vec4 t, vec2 Scales) {

              float fr = fract(t.z);
              t.z -= floor(t.zw);
              float Res;
              if (fr < 0.30) Res =  tex2D_bilinear4x(tex, t.xyzz, Scales);
              else
               if (fr > 0.70) Res =  tex2D_bilinear4x(tex, t.xyzz+vec4(0,0,1,1), Scales*vec2(0.5, 2));
               else {
                    Res = tex2D_bilinear4x(tex, t.xyzz, Scales);
                  float Res1 = tex2D_bilinear4x(tex, t.xyzz+vec4(0,0,1,1), Scales*vec2(0.5, 2));

                  fr=max(0.0,
                    min(1.0, (fr-0.30)*(1.0/(0.70-0.30)))
                  );//NB: saturate((fr-0.30)*(1.0/(0.70-0.30)));

                  Res = Res1*fr+Res*(1.0-fr);
              }

                return Res;//Res;
            }


            void main()
             {
              vfconn Out;

              //vec4 INP = IN.position;
              vec4 INP = vec4(position,1.0);
              INP.z+=VOfs.w;
              float FarRun = 0.0;
              INP.xy = INP.xy*(pow(INP.z,4.0)*VOfs.z);
              INP.z = 0.0;


              vec4 ClipPos = (modelViewMatrix * projectionMatrix) * INP;
              Out.HPOS = ClipPos;//mul(glstate.matrix.mvp, IN.position);//ClipPos;
              Out.COL0 = IN.COL0;

              bvec3 b0 = lessThan(abs(ClipPos.xyz), (ClipPos.www*1.15+1.5+FarRun));

              Out.TEX3.z  = 1.0;

              if (all(b0)) {
                float vDisp = 0.0;
                vec4 t;
                float  TexSize;
                float  scale;
                vec4 vPos = INP;
                float jf = IN.position.z+VOfs.w;

                t.xy = (INP.xy+VOfs.xy)*Gabarites.x;
                float MipDist2 = dot(INP.xy, INP.xy);//-CPos.xy;

                t.z = (MipDist2-50.0*50.0)*7.0/(300.0*300.0-50.0*50.0);//length(MipDist2)/3400
                t.z = clamp(t.z, 0.0, 7.0);//+FogTexScale.w;

                vec2 CS = vec2(cos(3.4*10.0/180.0),sin(3.4*10.0/180.0));
                Out.TEX2.xy = vec2(t.x*CS.x+t.y*CS.y, -t.x*CS.y+t.y*CS.x);

                TexSize = Gabarites.y*pow(2.0,-floor(t.z));
                scale =1.0/TexSize;
                vec2 Scales=vec2(TexSize, scale);


                 vDisp =  tex2D_trilinear/*tex2D_bilinear4x*/(HMap0, t.xyzz, Scales);

                 float Wavy = 1.0;


                if (jf < 200.0) {//second pass
                  float R = clamp(
                    (jf-50.0) *(1.0/(200.0-50.0)),
                    0.0,
                    1.0);//NB: saturate((jf-50) *(1.0/(200.0-50.0)));
                  float S = (1.0/5.1)*(1.0-R);

                  vec4 t1 = t.xyzw*5.1;
                  t1.zw = vec2(0,0);//flour 0;//clamp(ceil(R*3),0, 7);

                  float TexSize = Gabarites.y*pow(2.0,-t1.z);
                  float scale =1.0/TexSize;
                  vec2 Scales=vec2(TexSize, scale);
                  vDisp += (tex2D_bilinear4x(HMap1, t1, Scales))*S;
                }

                vDisp*=Gabarites.z;

               /* dynamic Explosions -  Sorry not finished
               if (Expld[0].w > 0) {
                 float time = Expld[1].w;
                 vec2 d = Expld[0].xy+INP.xy-CPos.xy;
                 float r2=dot(d,d);
                 vDisp.z += -cos(+sqrt(r2)*Expld[0].z+time)*min(Expld[0].w/r2, 10);
                }*/

                Out.TEX3.z  = Gabarites.w/(Gabarites.z*Gabarites.y*Wavy);
                Out.TEX3.w = (Wavy-0.25)*1.5;


                vPos.z = (vDisp-Gabarites.z*0.5)*Wavy;

                Out.TEX3.xy = t.xy;//vDisp.xy;
                Out.TEX6.xy = t.xy*vec2(0.293*6.28, 0.371*6.28)+MapRTrasf.z;


                vec2 tn = t.xy*vec2(3.33*2.1, 3.37*5.7);
                vec2 CS2 = vec2(sin(15.0*3.14/180.0), cos(15.0*3.14/180.0));
                vec2 _CS = vec2(-sin(15.0*3.14/180.0), cos(15.0*3.14/180.0));


                Out.TEX5 = t*5.1;//vDisp.xy;
                Out.TEX5.zw = vec2(tn.x*CS2.y+tn.y*CS2.x, -tn.x*CS2.x+tn.y*CS2.y); //vec2(dot(tn.xy,CS.yx), dot(tn.xy,CS.xy));


                Out.TEX4 = vPos-CPos;
                Out.HPOS = (modelViewMatrix * projectionMatrix) * vPos;

                gl_Position = Out.HPOS;// + vec4(position, 1.0);
              }

              //cant return...
              //return(Out);
             }
        </script>

        <script id="fragmentShader" type="x-shader/x-fragment">

        </script>


		<script>


		    if (!Detector.webgl) {

		        Detector.addGetWebGLMessage();
		        document.getElementById('container').innerHTML = "";

		    }

		    var container, stats;
		    var camera, controls, scene, renderer;
            var mesh, texture;
            var skyboxCamera, skyboxScene;
            var waterCamera, waterScene, waterGeometry, waterTexture, waterMesh;
			var waterUniforms;

		    var worldWidth = 256, worldDepth = 256,
			worldHalfWidth = worldWidth / 2, worldHalfDepth = worldDepth / 2;

		    var clock = new THREE.Clock();

		    init();
		    animate();

		    function init() {

		        container = document.getElementById('container');

		        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 20000);

		        scene = new THREE.Scene();

		        controls = new THREE.FirstPersonControls(camera);
		        controls.movementSpeed = 1000;
		        controls.lookSpeed = 0.1;

		        data = generateHeight(worldWidth, worldDepth);

		        camera.position.y = data[worldHalfWidth + worldHalfDepth * worldWidth] + 500;

		        var geometry = new THREE.PlaneGeometry(15000, 15000, worldWidth - 1, worldDepth - 1);
		        geometry.applyMatrix(new THREE.Matrix4().makeRotationX(-Math.PI / 2));

		        for (var i = 0, l = geometry.vertices.length; i < l; i++) {

		            geometry.vertices[i].y = data[i] * 10;

		        }
		        //compute normals
		        geometry.computeFaceNormals();
		        geometry.computeVertexNormals();

		        for (var i = 0, l = geometry.vertices.length; i < l; i++) {

		            geometry.vertices[i].y = data[i] * 10;

		        }
		        var ambientLight = new THREE.AmbientLight( 0x202020 ); // soft white light
		        var directionalLight = new THREE.DirectionalLight(0xffffff, 1.00);
		        scene.add( ambientLight );
		        directionalLight.position = new THREE.Vector3(0.3, 1.0, 0).normalize();
		        scene.add(directionalLight);

		        texture = THREE.ImageUtils.loadTexture("textures/sand.png");
		        texture.wrapS = THREE.RepeatWrapping;
		        texture.wrapT = THREE.RepeatWrapping;
		        texture.repeat.set(16, 16);
		        texture.needsUpdate = true;

		        mesh = new THREE.Mesh(geometry, new THREE.MeshLambertMaterial({ map: texture, wrapAround: true, wrapRPG: 0xFF0000 }));
		        scene.add(mesh);

		        // SKYBOX and WATER
                initSkybox();
                initWater();

		        window.addEventListener('resize', onWindowResize, false);

                renderer = new THREE.WebGLRenderer();
		        renderer.setClearColor(0xbfd1e5);
		        renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.autoClear = false;
                container.innerHTML = "";
		        container.appendChild(renderer.domElement);

		        stats = new Stats();
		        stats.domElement.style.position = 'absolute';
		        stats.domElement.style.top = '0px';
		        container.appendChild(stats.domElement);

		    }

		    function onWindowResize() {

		        camera.aspect = window.innerWidth / window.innerHeight;
		        camera.updateProjectionMatrix();

		        renderer.setSize(window.innerWidth, window.innerHeight);

		        controls.handleResize();

		    }

		    function generateHeight(width, height) {

		        var size = width * height, data = new Float32Array(size),
				perlin = new ImprovedNoise(), quality = 1, z = Math.random() * 100;

		        for (var i = 0; i < size; i++) {

		            data[i] = 0

		        }

		        for (var j = 0; j < 4; j++) {

		            for (var i = 0; i < size; i++) {

		                var x = i % width, y = ~~(i / width);
		                data[i] += Math.abs(perlin.noise(x / quality, y / quality, z) * quality * 1.75);


		            }

		            quality *= 5;

		        }

		        return data;

		    }

		    function initSkybox() {
                skyboxCamera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 3);
                skyboxCamera.quaternion = camera.quaternion;
                skyboxScene = new THREE.Scene();

                skyboxGeometry = new THREE.CubeGeometry(4, 1, 4);
                skyboxGeometry.faces.splice(4,4);
                //skyboxGeometry.applyMatrix(new THREE.Matrix4().makeTranslation(0, 0.5, 0));
                skyboxGeometry.elementsNeedUpdate = true;
                skyboxGeometry.verticesNeedUpdate = true;

                skyboxTexture = THREE.ImageUtils.loadTexture("textures/mountains.png", THREE.UVMapping);
                skyboxTexture.premultiplyAlpha = true;
                //skyboxTexture.generateMipmaps = false;

                skyboxMesh = new THREE.Mesh(skyboxGeometry, new THREE.MeshLambertMaterial({
                    shading: THREE.FlatShading,
                    transparent: true,
                    emissive: new THREE.Color(0xffffff),
                    fog: false,
                    map: skyboxTexture,
                    depthTest: false,
                    depthWrite: false,
                    side: THREE.BackSide
                }));
                skyboxScene.add(skyboxMesh);
            }

            function initWater() {
				/*var uniforms = {
					fogDensity: { type: "f", value: 0.45 },
					fogColor: { type: "v3", value: new THREE.Vector3( 0, 0, 0 ) },
					time: { type: "f", value: 1.0 },
					resolution: { type: "v2", value: new THREE.Vector2() },
					uvScale: { type: "v2", value: new THREE.Vector2( 3.0, 1.0 ) },
					texture1: { type: "t", value: THREE.ImageUtils.loadTexture( "textures/lava/cloud.png" ) },
					texture2: { type: "t", value: THREE.ImageUtils.loadTexture( "textures/lava/lavatile.jpg" ) }
				};*/

                var waterTexture = THREE.ImageUtils.loadTexture("textures/water1024.png");
                waterTexture.premultiplyAlpha = false;
                waterTexture.wrapS = THREE.RepeatWrapping;
                waterTexture.wrapT = THREE.RepeatWrapping;
                waterTexture.repeat.x = 32;
                waterTexture.repeat.y = 32;
                //waterTexture.generateMipmaps = false;
                //waterTexture.minFilter = THREE.NearestFilter;
                //waterTexture.magFilter = THREE.NearestFilter;
                waterGeometry = new THREE.PlaneGeometry(200000, 200000, worldWidth - 1, worldDepth - 1);
                waterGeometry.applyMatrix(new THREE.Matrix4().makeRotationX(-Math.PI/2));
				
							
				waterMesh = new THREE.Mesh(waterGeometry, new THREE.ShaderMaterial({
                    name: "WaterTestShader",
                    uniforms: shaderUniforms,
                    //defines: defines,
                    //fragmentShader: ,
                    //vertexShader: 
                }));

				/*//see three_lambertoon_anim.js
                var defines = {};
                defines[ "USE_MAP" ] = "true";
                var shaderUniforms = THREE.UniformsUtils.clone( THREE.WaterShader.uniforms );
                shaderUniforms[ "map" ].value = waterTexture;
                shaderUniforms[ "offsetRepeat" ].value.set( 0, 0, 32, 32 );
                shaderUniforms[ "diffuse" ].value = new THREE.Color(0x0067aa);
                waterMesh = new THREE.Mesh(waterGeometry, new THREE.ShaderMaterial({
                    name: "WaterTestShader",
                    uniforms: shaderUniforms,
                    defines: defines,
                    fragmentShader: THREE.WaterShader.fragmentShader,
                    vertexShader: THREE.WaterShader.vertexShader
                }));*/

                /*waterMesh = new THREE.Mesh(waterGeometry, new THREE.MeshLambertMaterial({
                    map: waterTexture
                }));*/

                scene.add(waterMesh);
            }

		    function animate() {

		        requestAnimationFrame(animate);

		        render();
		        stats.update();
		    }

		    function render() {
                renderer.render(skyboxScene, skyboxCamera, null, true);
		        controls.update(clock.getDelta());
                renderer.render(scene, camera);
		    }

		</script>

	</body>
</html>
